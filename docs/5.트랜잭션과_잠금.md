# 트랜잭션과 잠금 

- 잠금은 동시성 제어를 위한 기능이고, 트랜잭션은 데이터 정합성을 위해서 보장되는 기능이다.
  -  정합성은 데이터간의 모순이 있는지를 말하는 것임. 
- 격리 수준이라는 건 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 것. 
- MyISAM 이나 MEMORY 와 같은 스토로지 엔진은 InnoDB 와 달리 트랜잭션을 지원하지 않는다. 

## 트랜잭션 주의사항 

- 트랜잭션은 되도록 늦게 시작하고 빨리 끝나는게 좋다. 커넥션을 빨리 반환해야 더 성능이 높아지기 때문에.
  - 실제 데이터베이스 작업이 필요하기 전에, 어플리케이션에서 처리할 수 있는 로직이라면 처리하고 나서 트랜잭션을 시작하는게 좋다. 
- 트랜잭션에 포함되야 할 작업인지, 포함되면 안되는 작업인지 확인을 해야한다. 
  - 알림 메일 발송 같은 건 트랜잭션에 포함시키면 안된다. 
  - 단순 작업 후 조회라면 트랜잭션에 묶지 않아도 된다.

## MySQL 엔진의 잠금 

- MySQL 에서 사용하는 잠금은 크게 스토로지 엔진 레벨의 잠금과 MySQL 엔진 레벨로 나눌 수 있다. 
  - 스토로지 엔진 레벨의 잠금은 스토로지 끼리 상호작용을 안끼치는데 MySQL 엔진 레벨 잠금은 모든 스토로지 레벨의 잠금에 영향을 미친다. 
- MySQL 엔진의 락 
  - 테이블 데이터 동기화를 위한 테이블 락 
  - 테이블의 구조를 잠그는 메타데이터 락 
  - 사용자의 필요에 맞게 사용하는 네임드 락 

### 글로벌 락 (GLOBAL Lock)
- 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득이 가능하다. 
- MySQL 에서 제공하는 잠금 중에 가장 범위가 크다. 
- 일단 하나의 세션에서 이 락을 얻으면 다른 세션에서 SELECT 를 제외한 DDL, DML 문장을 실행하는 경우 다 막힌다.
- 영향이 미치는 범이는 MySQL 서버 전체. 즉 작업 대상 테이블이나, 데이터베이스가 다르더라도 영향을 미친다.
- 잠금을 걸기 전에 모든 테이블에서 실행중인 쿼리가 완료되어야함.
- mysqldump 와 같은 백업 작업을 할 때 이 락이 쓰여짐. 웬만하면 안써야함.  
- MySQL 8.0 부터 InnoDB 가 기본 엔진으로 채택되면서 글로벌 락의 영향이 좀 줄어듦
  - `Xtrabackup` 이나 `Enterprise Backup` 과 같은 백업 락이 도입됨 
  - `mysql) LOCK INSTANCE FOR BACKUP;` 백업 실행 
    - 테이블의 스키마나 인증 정보를 변경할 수 없다. 
    - 하지만 일반적인 테이블의 데이터 변경은 허용된다.
      - 백업은 주로 레플리카에서 실행. 
  - `mysql) UNLOCK INSTANCE`

### 테이블 락 (Table Lock)
- 테이블 락은 개별 테이블 단위로 잠그는 락. 
- 명시적 또는 묵시적으로 락을 획득할 수 있다. 
  - 명시적으로는 `LOCK TABLES table_name [READ | WRITE]` 명령으로 얻을 수 있다. 
  - 푸는 건 `UNLOCK`
  - 묵시적인 락은 쿼리를 실행하는 동안 생기고, 쿼리 실행이 끝나면 풀린다. 
- InnoDB 의 경우 레코드 기반의 락을 제공하기 떄문에 단순 데이터 변경으로 인해서 묵시적인 테이블 락이 설정되진 않는다.
  - 스키마 변경 같은 경우만 미친다.

### 네임드 락 (Named Lock)
- `GET_LOCK()` 을 통해서 임의의 문자열에 대해 잠금을 설정할 수 있다. 
- 이 락은 테이블이나 레코드 또는 AUTO_INCREMENT 와 같은 데이터베이스 객체가 아니다 라는 것. 
- 단순히 사용자가 지정한 문자열에 대해서 획득하고 반납하는 락이다. 자주 사용되지는 않는다. 
- 주로 쓰인는 곳은 배치프로그램에서 한번에 많은 레코드를 변경하는 쿼리의 경우 데드락이 자주 발생할 수 있는데 이 경우에 네임드 락을 걸어서 해결할 수 있다.
  - 그냥 작업을 할 때 잠시 방해하지 말라고 거는거야.
    - 사용자가 락이 필요할 떄 쓰이는 형태겠네. 
  - 물론 데드락은 프로그램의 실행 시간을 변경하거나 코드를 수정하면 해결할 수도 있지만 완전한 해결책은 아니다. 
- `SELECT GET_LOCK('my_lock', 10)` 으로 걸 수 있다. 
- `SELECT RELEAE_LOCK('my_lock')` 으로 풀 수 있다. 
- `SELECT RELEASE_ALL_LOCKS();` 으로 모두 해제하는 게 가능하다. 

### 메타데이터 락 (Metadata lock) 
- 메타데이터 락은 데이터베이스 객체 (테이블이나 뷰) 의 이름이나 구조를 변경하는 경우에 획득하는 락이다. 
  - 데이버테이스 객체를 변경하는 경우. (이게 메타데이터)
- 메타데이터 락은 명시적으로 획득하거나 해제할 수 있지 않다. 
  - `RENAME TABLE tab_a TO tab_b` 와 같은 테이블의 이름을 변경하는 쿼리의 경우 자동으로 얻어지는 락이다.
  - `RENAME TABLE` 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 건다. 
  - 테이블 이름을 바꿔야하는 배치 프로그램에서 자주 쓰인다는 듯. 
    - 임시 테이블로 쓰다가 RENAME 해서 바꾸는 것. 한번에 바꿀 수 있으니까.
  - `RENAME TABLE rank TO rank_backup, rank_new TO rank;` 이런식으로 한번에 바꾸는 것도 가능함. 
    - 이렇게 한번에 두 개의 테이블을 동시에 바ㅜ면 `TABLE not found rank` 와 같은 상황을 발생시키지 않는다.
- 때로는 메타데이터 락과 트랜잭션을 같이 써야하는 순간도 있다.
  - DDL 을 바꿔야 하는 경우. 근데 적재되는 속도가 빠른 경우. 예로 들면 로그가 적재되는 것. 
  - MySQL DDL 은 하나의 스레드로 작업되기 때문에 느리다. 
  - 그래서 이때는 새로운 테이블을 생성하고 최근 한시간 전까지 데이터를 여러 스레드로 복사시킨다. 
  - 그 다음 트랜잭션을 autocommit 으로 실행시킨다. 
    - 데이터가 들어오지 않도록 바꿀 테이블과 바뀔 테이블 모두 테이블 락을 건다.
    - 남은 데이터를 모두 복사한다. 
    - 커밋한다. (트랜잭션 끝.)
    - `RENAME TABLKE` 로 테이블을 바꿔치기 한다. 
    - `UNLOCK` 을 한다.
    - 불필요한 테이블 삭제한다.

#### 테이블 락은 뭐지? 이 락이 잠기면 테이블에 접근이 안되는건가? 

- 전체 테이블을 잠근다. 

#### 글로벌 락은 MySQL 엔진의 락인가? 

- ㅇㅇ 다 mysql 락이다. 
  - 테이블 락
  - 네임드 락
  - 메타데이터 락

#### 왜 트랜잭션 autocommit 을 하지? BEGIN 과 START_TRANSACTION 이랑 차이가 뭐지

- autocommit
  - 기본적으로 적용되어 있음. 
    - 아 그래서 각각의 statement 가 atomic 한 이유.  
  - read-only transaction 에 강하다. 
  - locking 과 undo data generation overhead 가약하다.
    - rollback 이 불가능함. 대신 실행 중 에러가 발생하면 롤백됨.
    - 원래 트랜잭션을 시작하면 COMMIT 과 ROLLBACK 을 명시적으로 가능한데, 여기선 안되는듯. 

- START TRANSACTION 
  - 이걸 쓰면 autocommit 은 disable 됨. 
  - multiple statement 에 쓸 때 사용함.

## InnoDB 스토로지 엔진 잠금 

- 스토로지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있음. 
  - InnoDB 는 이 방식 때문에 훨씬 동시성 처리가 뛰어남. 
- InnoDB 에서 트랜잭션 목록을 조회할려면 `information_schema` 를 조회하면 된다. 
  - `INNODB_TRX`
  - `INNODB_LOCKS`
  - `INNODB_LOCK_WAITS`
  - 이 테이블들을 조회하면 현재 어떤 트랜잭션이 잠금을 대기하고 있고, 해당 잠금을 어느 트랜잭션에서 잠금을 가지고 있는지 확인이 가능하다. 
- `Performance_schema` 를 이용하면 스토로지 엔진 내부 잠금 세마포어에 대한 모니터링도 가능하다. 


### 레코드락 (Record Lock) 

- 레코드 자체만을 잠그는 것을 레코드 락이라고 한다. 
- InnoDB 스토로지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 것.
  - 인덱스가 하나라도 없지 않다. 
  - 자동으로 생성되는 클러스터링 인덱스가 있기 때문에. 이를 이용해서 잠금을 한다. 
  - 레코드 자체를 잠그냐, 인덱스를 잠그냐는 꽤 중요한 차이를 낸다. 

- 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락 (Next Key lock) 또는 갭 락 (Gap Lock) 을 사용하다. 
- 그리고 프라이머리 키 또는 유니크 인덱스에 의한 변경은 갭 (GAP) 에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다. 

### 갭 락 (GAP Lock)

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락이다.
- 이 역할은 레코드와 레코드 사이에 새로운 값이 Insert 되지 않도록 막는 락이다. 
- 이것 자체 보다는 넥스트 키 락의 일부로 자주 사용된다. 

### 넥스트 키 락 

- 레코드 락과 갭 락을 합쳐놓은 게 넥스트 키 락 이다. 

### 자동 증가 락 

- MySQL 에서는 자동 증가하는 숫자 값을 추출하기 위해서 AUTO_INCREMENT 라는 칼럼 속성을 제공한다.
- AUTO_INCREMENT 가 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야한다.
InnoDB 에서는 이를 위해서 내부적으로 AUTO_INCREMENT 락이라고하는 테이블 수준의 잠금을 사용한다. 

- AUTO_INCREMENT 락은 Insert 와 Replace 와 같은 새로운 레코드를 저장하는 경우에만 사용하지, Update 나 DELETE 등의 쿼리에는 사용되지 않는다. 
- 이 락은 AUTO_INCREMENT 값을 가져오는 순간에만 락이 걸렸다가 즉시 해제된다. 
- 이건 테이블에 단 하나만 존재한다. 
  - 즉 두 개의 Insert 쿼리가 동시에 들어오는 경우에 하나는 잠시 기다려야한다.

- MySQL 5.1 부터는 `innodb_autoinc_lock_mode` 라는 시스템 변수를 이용해서 자동 증가 락의 작동 방식을 변경하는 것도 가능하다. 
  - `innodb_autoinc_lock_mode=0`
    - 모든 INSERT 문장은 자동 증가 락을 사용한다. 
  - `innodb_autoinc_lock_mode=1`
    - 단순히 한 건 또는 여러건이지만 레코드의 건수를 정확히 예측할 수 있을 때에는 자동 증가 락을 사용햐지 않고 훨씬 가벼운 래치 (뮤택스) 를 이용해서 처리한다.
    - 하지만 `INSERT ... SELECT` 와 같이 서버가 건수를 정확히 예측하지 못하는 경우에는 자동 증가 락을 사용한다. 이때는 Insert 문장이 완료되기 전에는 자동 증가 락은 해제되지 않는다. 즉 대기해야함. 
    - 그리고 자동 증가 값을 한번에 할당 받아서 INSERT 하는데 사용함. 그래서 레코드는 연속적으로 증가한다. 이때문에 이름은 `Consecuitvie mode` 라고 부르기도함.
  - `innodb_autoinc_lock_mode=2`
    - 자동 증가 락을 절대 사용하지 않음. 경량화된 뮤텍스를 이용한다. 
    - 하지만 이 경우에는 하나의 insert 를 추가하는 경우에도 연속된 자동 증가 값을 보장하지는 않는다. 
    - 그래서 이 설정 모드를 `interleaved mode` 라고 부르기도한다.
    - 이 경우에는 `INSERT ... SELECT` 를 하는 도중에도 다른 커넥션에서 INSERT 가 가능해서 동시 처리 성능이 올라간다. 
    - 그리고 자동 증가 값은 유니크함을 보장해준다. 
    - 대신 `STATEMENT` 의 바이너리 로그를 사용하는 경우에는 레플리카 서버의 자동 증가 값이 달라질 수 있다. 
  - MySQL 8.0 에서는 `innodb_autoinc_lock_mode=2` 이게 기본이다. 
    - 왜냐하면 바이너리 로그 포맷이 `STATEMENT` 가 아니라 `ROW` 포맷으로 변경되어서. 

### 인덱스와 잠금 

- 예시로 보면 이해하기 쉬움.
  -  `employees` 테이블에는 `idx_firstname` 이라는 인덱스가 있음. 즉 이걸로만 레코드 락을 거는게 가능함.
  - `firstName: 'Georgi'` 인 사람은 253 명이지만, `first_name: 'Georgi'` 이고, `last_name: 'Klassen'` 인 사람은 1명이다.
  - 이를 이용해서 `UPDATE employees SET hire_data=NOW() WHERE first_name='Georgi' AND last_name='Klassen'` 을 하면 레코드락은 몇 개를 걸어야할까? 
  - `last_name` 쪽에는 인덱스가 없어서 254 건을 걸어야한다. 
  - 즉 이를 알고 인덱스 설계를 해야함.

### 레코드 수준의 잠금 확인 및 해제 

- `information_schema` 에서 잠금을 걸고 확인하는 것도 가능하지만 deprecate 되고 있기 때문에 `peformance_schema` 에서 확인하자. 
  - `data_locks` 와 `data_lock_waits` 로 확인.

#### 뮤텍스가 락보다 가볍다고 한는데 이유는 뭔데? 

- 동시성 제어 방법들에 대해서 알아봐야하나? 
  - mutex, lock, semaphore 에 대해서.
- lock
  - only one thread 만 접근이 가능하도록 하는 것. 다른 프로세스와 공유가 안됨. 
  - mechanism 이라고 생각하면 됨. 동기화를 위한. 
- mutex
  - lock 과 같지만 system wide 라서 여러 프로세스에서 공유할 수 있음.
  - synchronization object 임. 이걸 가지고 있는 사람만 들어갈 수 있음.
  - DBMS 에서 mutex 는 latch 로 해석되며 정의는 물리적인 리소스에 짧은 시간동안 (읽기/쓰기) 를 획득해서 작업하고자 할 단위를 말한다.
    - 짧은 시간이라는 말 자체가 상대적인 개념이고, 빠른 연산을 위해서 지원한다 라는 듯. 
- semaphore
  - x number of thread 가 들어올 수 있음.택


## MySQL 격리수준 

- `SERIALIZABLE` 수준이 아니라면 크게 성능이 떨어지지 않는다. 

- 이상현상으로 여기선 `Dirty Read`, `NON-REPEATABLE READ`, `PHANTOM READ` 가 있고 이를 소개한다. 

- `NON-REPEATABLE READ`
  - 일관된 읽기가 아님. 
  - 트랜잭션 시작한 시점 t1 에서는 조회가 없었는데, 이후에 다른 트랜잭션에서 커밋이 되면 t2 시점에는 조회가 가능할 수 있음. 
  - 동일 데이터를 여러번 읽는 금전과 관련된 프로그램에서 문제가 될 수 있음. 
    - 입금과 출금이 계속돠는 프로그램이라면 REPEATABLE READ 가 보장되지 않기 떄문에 SELECT 는 계속 다른 값일 것.
    - REPEATABLE READ 에서는 트랜잭션 내에서 보는 SELECT 와 동일함. 일관된 읽기. 

### REPEATABLE READ 

- MySQL InnoDB 엔진에서 제공하는 기본 격리수준. 
- MVCC 로 문서의 여러가지 버전이 있다. 그리고 Rollback 될 가능성에 대처하기 위해서 UNDO 공간에 백업으로 기록해놓고.
  - 가장 오래된 트랜잭션의 번호보다 앞선 트랜잭션이 해당 데이터를 삭제할 순 없다. 마킹해놓고, 진짜 안쓰는 시점에 지우겠지.
    - `created_by` 와 `deleted_by` 라는 필드가 있음. 
- InnoDB 의 트랜잭션은 모두 고유의 번호가 있다. 
  - UNDO 공간에는 레코드를 변경시킨 트랜잭션 번호가 담겨있다. 
    - 이걸 안쓴다면 불필요한 시점에 알아서 잘 삭제함. 
  - 트랜잭션 번호는 점차 올라간다고 생각하면 됨. 
  - 자신의 트랜잭션보다 높은 트랜잭션 번호를 가진 레코드는 읽지 않는다.
    - 자신의 트랜잭션보다 높은 트랜잭션이 레코드를 변경하면 UNDO 공간에 백업으로 데이터가 있다. 이 백업은 트랜잭션 번호가 낮을 것이므로 이걸 읽는다.
- 주의할 건 한 사용자의 트랜잭션이 지나치게 길다면 UNDO 공간에 백업 데이터가 엄청나게 쌓일 수 있다. 
- InnoDB 에서는 갭락과 넥스트 키 락 때문에 Phantom READ 가 일어나진 않는다.

### PHANTOM READ

- `SELECT ... FOR UPDATE` 로 읽으면 이는 명시적인 잠금을 거는건데 UNDO 영역에 있는 레코드에 잠금을 걸 수 없다. 그래서 늘 최신의 데이터를 읽을 수 밖에 없다.
  - 단순 SELECT 라면 자신보다 트랜잭션 번호가 작은 데이터는 안읽으면 되니. 
- 그래서 SELECT 시에 데이터가 추가되거나 제거되는 경우를 볼 수 있는데 이게 PHANTOM READ 임. 
- 근데 InnoDB 에서는 갭락과 넥스트 키 락이 있기 때문에 이런 현상은 없다고 한다.

### SERIALIZABLE 

- 이 격리라면 읽기 작업도 shared lock (공유 잠금) 을 읽어야 하며, 동시에 다른 트랜잭션은 레코드를 변경하지 못한다.  
- 한 트랜잭션이 읽고 쓰는 동안에 다른 트랜잭션은 절대 접근할 수 없다. 



